/* Copyright (c) 2007 Cyrus Daboo. All rights reserved.  Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. *///	Draws and tracks clicks for a drop flag.#ifdef PowerPlant_PCH	#include PowerPlant_PCH#endif#include <LDropFlag.h>#include <UEventMgr.h>#include <UGWorld.h>#include <Icons.h>PP_Begin_Namespace_PowerPlant//	Icon family resource ID's for the states of the drop flag//	The size of the rectangle you pass to Draw and TrackClick determine//	which icon size gets used.//		Large Icon		32 x 32//		Small Icon		16 x 16//		Mini Icon		16 x 12const ResIDT	icon_Up			= 10000;const ResIDT	icon_UpDark		= icon_Up + 1;const ResIDT	icon_Side		= 10004;const ResIDT	icon_Down		= 10002;const ResIDT	icon_DownDark	= icon_Down + 1;const SInt32		delay_Animation	= 4;// ---------------------------------------------------------------------------//		¥ Draw// ---------------------------------------------------------------------------//	Draw aLDropFlag at a particular location with the specified//	orientationvoidLDropFlag::Draw(	const Rect	&inRect,	bool		inIsDown){#if PP_Target_Carbon	if (UEnvironment::HasFeature(env_HasAquaTheme))	{		Rect r = inRect;		//::OffsetRect(&r, 1, 1);		ThemeButtonDrawInfo theme;		theme.state = kThemeStateActive;		theme.value = inIsDown ? kThemeDisclosureDown : kThemeDisclosureRight;		theme.adornment = kThemeAdornmentNone;		::DrawThemeButton(&r, kThemeDisclosureButton, &theme, NULL, NULL, NULL, NULL);	}	else#endif	{		ResIDT	iconID = icon_Up;		if (inIsDown) {			iconID = icon_Down;		}		::EraseRect(&inRect);		::PlotIconID(&inRect, atNone, ttNone, iconID);	}}// ---------------------------------------------------------------------------//	¥ TrackClick// ---------------------------------------------------------------------------//	Track the mouse after an initial click inside a LDropFlag. This//	functions draws the hilited and intermediate states of the flag//	as necessary, so the current port must be set up properly.////	inRect specifies the location of the DropFlag//	inMouse is the mouse location (usually from a MouseDown EventRecord)//		in local coordinates//	inIsUp specifies if the flag was up or down when the click started////	Returns whether the mouse was release inside the DropFlag.BooleanLDropFlag::TrackClick(	const Rect	&inRect,	const Point	&inMouse,	bool		inIsDown){	Boolean		goodClick = false;		if (!::MacPtInRect(inMouse, &inRect)) {		return false;	}	#if PP_Target_Carbon	if (UEnvironment::HasFeature(env_HasAquaTheme))	{		Rect r = inRect;		//::OffsetRect(&r, 1, 1);				// Setup two theme states - pressed and not pressed		ThemeButtonDrawInfo themeNormal;		themeNormal.state = kThemeStateActive;		themeNormal.value = inIsDown ? kThemeDisclosureDown : kThemeDisclosureRight;		themeNormal.adornment = kThemeAdornmentNone;		ThemeButtonDrawInfo themePress;		themePress.state = kThemeStatePressed;		themePress.value = inIsDown ? kThemeDisclosureDown : kThemeDisclosureRight;		themePress.adornment = kThemeAdornmentNone;												// For the initial mouse down, the										// mouse is currently inside the HotSpot										// when it was previously outside		Boolean		currInside = true;		Boolean		prevInside = false;		::DrawThemeButton(&r, kThemeDisclosureButton, &themePress, NULL, NULL, NULL, NULL);												// Track the mouse while it is down		Point	currPt = inMouse;		while (::StillDown()) {			::GetMouse(&currPt);		// Must keep track if mouse moves from			prevInside = currInside;	// In-to-Out or Out-To-In			currInside = MacPtInRect(currPt, &inRect);						if (prevInside != currInside) {				::DrawThemeButton(&r, kThemeDisclosureButton, currInside ? &themePress :  &themeNormal, NULL, NULL, NULL, NULL);			}		}				EventRecord	macEvent;			// Get location from MouseUp event		if (UEventMgr::GetMouseUp(macEvent)) {			currPt = macEvent.where;			::GlobalToLocal(&currPt);		}										// Check if MouseUp occurred in HotSpot		goodClick = ::MacPtInRect(currPt, &inRect);				if (goodClick) {			// Transition states			ThemeButtonDrawInfo themeNew;			themeNew.state = kThemeStateActive;			themeNew.value = inIsDown ? kThemeDisclosureRight : kThemeDisclosureDown;			themeNew.adornment = kThemeAdornmentNone;			// Draw new state with transition			::DrawThemeButton(&r, kThemeDisclosureButton, &themeNew, &themeNormal, NULL, NULL, NULL);		} else {						// Draw original state			::DrawThemeButton(&r, kThemeDisclosureButton, &themeNormal, NULL, NULL, NULL, NULL);		}	}	else#endif	{		ResIDT		iconID = icon_Up;		if (inIsDown) {			iconID = icon_Down;		}												// For the initial mouse down, the										// mouse is currently inside the HotSpot										// when it was previously outside		Boolean		currInside = true;		Boolean		prevInside = false;		::EraseRect(&inRect);		::PlotIconID(&inRect, atNone, ttNone, iconID + 1);												// Track the mouse while it is down		Point	currPt = inMouse;		while (::StillDown()) {			::GetMouse(&currPt);		// Must keep track if mouse moves from			prevInside = currInside;	// In-to-Out or Out-To-In			currInside = MacPtInRect(currPt, &inRect);						if (prevInside != currInside) {				ResIDT	trackIconID = iconID;				if (currInside) {					trackIconID = iconID + 1;				}				::EraseRect(&inRect);				::PlotIconID(&inRect, atNone, ttNone, trackIconID);			}		}				EventRecord	macEvent;			// Get location from MouseUp event		if (UEventMgr::GetMouseUp(macEvent)) {			currPt = macEvent.where;			::GlobalToLocal(&currPt);		}										// Check if MouseUp occurred in HotSpot		goodClick = ::MacPtInRect(currPt, &inRect);				if (goodClick) {			RGBColor	backColor;			::GetBackColor(&backColor);						UInt32	ticks;				// Draw intermediate state			::Delay(delay_Animation, &ticks);						{				StOffscreenGWorld	offWorld(inRect, 0, 0, nil, nil, &backColor);				::EraseRect(&inRect);				::PlotIconID(&inRect, atNone, ttNone, icon_Side);			}						::Delay(delay_Animation, &ticks);													// Draw dark end state			ResIDT	endIconID = icon_Down + 1;			if (inIsDown) {				endIconID = icon_Up + 1;			}						{				StOffscreenGWorld	offWorld(inRect, 0, 0, nil, nil, &backColor);				::EraseRect(&inRect);				::PlotIconID(&inRect, atNone, ttNone, endIconID);			}						::Delay(delay_Animation, &ticks);										// Draw normal end state			::EraseRect(&inRect);			::PlotIconID(&inRect, atNone, ttNone, endIconID - 1);					} else {						// Draw original state			::EraseRect(&inRect);			::PlotIconID(&inRect, atNone, ttNone, iconID);		}	}		return goodClick;}PP_End_Namespace_PowerPlant